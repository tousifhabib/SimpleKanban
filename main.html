<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Dynamic Kanban Board</title>
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/base.css">
    <link rel="stylesheet" href="css/layout.css">
    <link rel="stylesheet" href="css/components.css">
    <link rel="stylesheet" href="css/modal.css">
    <link rel="stylesheet" href="css/responsive.css">
</head>
<body>
<header>
    <h1>Dynamic Kanban Board</h1>
    <button class="add-column-btn" id="addColumnBtn">+ Add Column</button>
</header>

<div class="kanban-container" id="kanbanContainer"></div>

<!-- Add Column Modal -->
<div class="modal" id="addColumnModal" aria-hidden="true">
    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="modal-content" role="dialog" aria-labelledby="modalTitle" aria-modal="true">
        <h2 id="modalTitle">Add New Column</h2>
        <form id="addColumnForm">
            <input
                    type="text"
                    id="columnTitleInput"
                    class="column-input"
                    placeholder="Column Title"
                    required
            />
            <div class="button-group">
                <button type="submit" class="btn btn-primary">Add Column</button>
                <button type="button" class="btn btn-secondary" id="cancelAddColumn">Cancel</button>
            </div>
        </form>
    </div>
</div>

<template id="columnTemplate">
    <div class="column" draggable="true">
        <div class="column-header">
            <h2 contenteditable="true"></h2>
            <button data-action="delete-column">&times;</button>
        </div>
        <div class="cards"></div>
        <button class="add-card-btn">+ Add a card</button>
        <div class="add-card-form">
            <textarea class="card-input" rows="3" placeholder="Enter card title..."></textarea>
            <div class="button-group">
                <button class="btn btn-primary" data-action="confirm-add-card">Add Card</button>
                <button class="btn btn-secondary" data-action="cancel-add-card">Cancel</button>
            </div>
        </div>
    </div>
</template>

<template id="cardTemplate">
    <div class="card" draggable="true">
        <span class="card-text"></span>
        <div class="card-actions">
            <button class="card-action-btn" data-action="edit">‚úèÔ∏è</button>
            <button class="card-action-btn" data-action="delete">üóë</button>
        </div>
    </div>
</template>

<script>
    const STORAGE_KEY = 'flexibleKanbanState';
    let state = loadState();

    const kanbanContainer = document.getElementById('kanbanContainer');
    const addColumnBtn = document.getElementById('addColumnBtn');
    const columnTemplate = document.getElementById('columnTemplate');
    const cardTemplate = document.getElementById('cardTemplate');

    const addColumnModal = document.getElementById('addColumnModal');
    const modalOverlay = document.getElementById('modalOverlay');
    const addColumnForm = document.getElementById('addColumnForm');
    const columnTitleInput = document.getElementById('columnTitleInput');
    const cancelAddColumnBtn = document.getElementById('cancelAddColumn');

    function saveState() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    function loadState() {
        try {
            const saved = JSON.parse(localStorage.getItem(STORAGE_KEY));
            return saved || { columns: [] };
        } catch {
            return { columns: [] };
        }
    }

    function generateId(type) {
        const id = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).substr(2, 9);
        return type === 'column' ? `column-${id}` : `card-${id}`;
    }

    function renderBoard() {
        kanbanContainer.innerHTML = '';
        state.columns.forEach(col => {
            kanbanContainer.appendChild(createColumnElement(col));
        });
    }

    function createColumnElement(colData) {
        const colEl = columnTemplate.content.firstElementChild.cloneNode(true);
        colEl.dataset.columnId = colData.id;
        colEl.querySelector('h2').textContent = colData.title;
        colData.cards.forEach(card => {
            colEl.querySelector('.cards').appendChild(createCardElement(card));
        });
        setupColumnListeners(colEl);
        return colEl;
    }

    function createCardElement(cardData) {
        const cardEl = cardTemplate.content.firstElementChild.cloneNode(true);
        cardEl.dataset.cardId = cardData.id;
        cardEl.querySelector('.card-text').textContent = cardData.text;
        cardEl.addEventListener('dragstart', handleCardDragStart);
        cardEl.addEventListener('dragend', handleCardDragEnd);
        return cardEl;
    }

    function setupColumnListeners(colEl) {
        const addCardBtn = colEl.querySelector('.add-card-btn');
        const addCardForm = colEl.querySelector('.add-card-form');
        const confirmAddCardBtn = addCardForm.querySelector('[data-action="confirm-add-card"]');
        const cancelAddCardBtn = addCardForm.querySelector('[data-action="cancel-add-card"]');
        const deleteColumnBtn = colEl.querySelector('[data-action="delete-column"]');
        const columnHeader = colEl.querySelector('.column-header h2');

        addCardBtn.addEventListener('click', () => {
            addCardBtn.style.display = 'none';
            addCardForm.classList.add('active');
            addCardForm.querySelector('.card-input').focus();
        });

        confirmAddCardBtn.addEventListener('click', () => {
            const input = addCardForm.querySelector('.card-input');
            const text = input.value.trim();
            if (text) addNewCard(colEl.dataset.columnId, text);
            input.value = '';
            addCardForm.classList.remove('active');
            addCardBtn.style.display = 'block';
        });

        cancelAddCardBtn.addEventListener('click', () => {
            addCardForm.classList.remove('active');
            addCardBtn.style.display = 'block';
        });

        deleteColumnBtn.addEventListener('click', () => {
            if (confirm('Delete this column and all its cards?')) {
                state.columns = state.columns.filter(c => c.id !== colEl.dataset.columnId);
                saveState();
                renderBoard();
            }
        });

        columnHeader.addEventListener('blur', () => {
            const newTitle = columnHeader.textContent.trim() || 'Untitled Column';
            columnHeader.textContent = newTitle;
            const col = state.columns.find(c => c.id === colEl.dataset.columnId);
            if (col) col.title = newTitle;
            saveState();
        });

        colEl.addEventListener('dragstart', handleColumnDragStart);
        colEl.addEventListener('dragend', handleColumnDragEnd);
        colEl.addEventListener('dragover', e => e.preventDefault());
        colEl.addEventListener('drop', handleColumnDrop);
    }

    function addNewColumn(title) {
        state.columns.push({ id: generateId('column'), title: title || 'New Column', cards: [] });
        saveState();
        renderBoard();
    }

    function addNewCard(colId, text) {
        const col = state.columns.find(c => c.id === colId);
        if (col) {
            col.cards.push({ id: generateId('card'), text });
            saveState();
            renderBoard();
        }
    }

    function editCard(colId, cardId, newText) {
        const col = state.columns.find(c => c.id === colId);
        if (!col) return;
        const card = col.cards.find(cd => cd.id === cardId);
        if (card) card.text = newText;
        saveState();
        renderBoard();
    }

    function deleteCard(colId, cardId) {
        const col = state.columns.find(c => c.id === colId);
        if (col) {
            col.cards = col.cards.filter(c => c.id !== cardId);
            saveState();
            renderBoard();
        }
    }

    function handleCardDragStart(e) {
        e.stopPropagation();
        e.target.classList.add('dragging');
        e.dataTransfer.setData('text/plain', e.target.dataset.cardId);
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleCardDragEnd(e) {
        e.target.classList.remove('dragging');
        saveState();
    }

    kanbanContainer.addEventListener('dragover', e => {
        e.preventDefault();
        const draggedCard = document.querySelector('.card.dragging');
        if (!draggedCard) return;
        const targetCards = e.target.closest('.cards');
        if (!targetCards) return;
        const afterEl = getCardAfterElement(targetCards, e.clientY);
        afterEl ? targetCards.insertBefore(draggedCard, afterEl) : targetCards.appendChild(draggedCard);
    });

    kanbanContainer.addEventListener('drop', e => {
        e.preventDefault();
        const draggedData = e.dataTransfer.getData('text/plain');
        const isCard = !draggedData.startsWith('column-');
        if (!isCard) return;
        const draggingCard = document.querySelector('.card.dragging');
        if (!draggingCard) return;
        const newCol = e.target.closest('.column');
        if (!newCol) return;
        let cardData;
        state.columns.forEach(col => {
            const idx = col.cards.findIndex(c => c.id === draggingCard.dataset.cardId);
            if (idx !== -1) cardData = col.cards.splice(idx, 1)[0];
        });
        if (cardData) {
            const newColId = newCol.dataset.columnId;
            const targetCol = state.columns.find(c => c.id === newColId);
            const targetCardsContainer = newCol.querySelector('.cards');
            const afterEl = getCardAfterElement(targetCardsContainer, e.clientY);
            const insertIndex = afterEl ? targetCol.cards.findIndex(c => c.id === afterEl.dataset.cardId) : targetCol.cards.length;
            targetCol.cards.splice(insertIndex, 0, cardData);
            saveState();
            renderBoard();
        }
    });

    function getCardAfterElement(container, y) {
        const cards = [...container.querySelectorAll('.card:not(.dragging)')];
        return cards.reduce(
            (closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                return offset < 0 && offset > closest.offset ? { offset, element: child } : closest;
            },
            { offset: Number.NEGATIVE_INFINITY }
        ).element;
    }

    let draggedColumn = null;

    function handleColumnDragStart(e) {
        draggedColumn = e.target.closest('.column');
        if (!draggedColumn) return;
        draggedColumn.classList.add('dragging');
        e.dataTransfer.setData('text/column', draggedColumn.dataset.columnId);
        e.dataTransfer.effectAllowed = 'move';
    }

    function handleColumnDragEnd() {
        if (draggedColumn) {
            draggedColumn.classList.remove('dragging');
            draggedColumn = null;
            reorderColumns();
            saveState();
            document.querySelectorAll('.column').forEach(col => {
                col.style.transition = '';
                col.style.transform = '';
            });
        }
    }

    function handleColumnDrop(e) {
        e.preventDefault();
    }

    kanbanContainer.addEventListener('dragenter', e => e.preventDefault());

    let lastAfterElement = null;

    kanbanContainer.addEventListener('dragover', e => {
        e.preventDefault();
        const draggedCol = document.querySelector('.column.dragging');
        if (!draggedCol) return;

        const afterEl = getColumnAfterElement(kanbanContainer, e.clientX);

        if (afterEl !== lastAfterElement) {
            lastAfterElement = afterEl;

            const columns = Array.from(kanbanContainer.querySelectorAll('.column:not(.dragging)'));
            const initialRects = new Map();
            columns.forEach(col => initialRects.set(col, col.getBoundingClientRect()));

            if (afterEl && afterEl !== draggedCol) {
                kanbanContainer.insertBefore(draggedCol, afterEl);
            } else if (!afterEl) {
                kanbanContainer.appendChild(draggedCol);
            }

            // For each non-dragging column, calculate and apply the delta via a CSS variable.
            columns.forEach(col => {
                const oldRect = initialRects.get(col);
                const newRect = col.getBoundingClientRect();
                const deltaX = oldRect.left - newRect.left;
                const deltaY = oldRect.top - newRect.top;

                col.style.transition = 'none';
                col.style.setProperty('--flip-transform', `translate(${deltaX}px, ${deltaY}px)`);
            });

            requestAnimationFrame(() => {
                columns.forEach(col => {
                    col.style.transition = 'transform 300ms ease';
                    col.style.removeProperty('--flip-transform');
                });
            });
        }
    });

    function getColumnAfterElement(container, x) {
        const columns = [...container.querySelectorAll('.column:not(.dragging)')];
        return columns.reduce(
            (closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = x - box.left - box.width / 2;
                return offset < 0 && offset > closest.offset ? { offset, element: child } : closest;
            },
            { offset: Number.NEGATIVE_INFINITY }
        ).element;
    }

    function reorderColumns() {
        const colEls = [...document.querySelectorAll('.column')];
        state.columns = colEls.map(el => state.columns.find(c => c.id === el.dataset.columnId));
    }

    document.addEventListener('click', e => {
        const btn = e.target.closest('.card-action-btn');
        if (!btn) return;
        const action = btn.dataset.action;
        const cardEl = btn.closest('.card');
        const colEl = btn.closest('.column');
        if (!cardEl || !colEl) return;
        const cardId = cardEl.dataset.cardId;
        const colId = colEl.dataset.columnId;
        if (action === 'edit') {
            const current = cardEl.querySelector('.card-text').textContent.trim();
            const newText = prompt('Edit card text:', current);
            if (newText !== null && newText.trim()) editCard(colId, cardId, newText.trim());
        } else if (action === 'delete') {
            if (confirm('Delete this card?')) deleteCard(colId, cardId);
        }
    });

    addColumnBtn.addEventListener('click', openAddColumnModal);
    cancelAddColumnBtn.addEventListener('click', closeAddColumnModal);
    modalOverlay.addEventListener('click', closeAddColumnModal);
    addColumnForm.addEventListener('submit', handleAddColumnSubmit);

    function openAddColumnModal() {
        addColumnModal.classList.add('active');
        addColumnModal.setAttribute('aria-hidden', 'false');
        columnTitleInput.focus();
    }

    function closeAddColumnModal() {
        addColumnModal.classList.remove('active');
        addColumnModal.setAttribute('aria-hidden', 'true');
        addColumnForm.reset();
    }

    function handleAddColumnSubmit(e) {
        e.preventDefault();
        const title = columnTitleInput.value.trim();
        if (title) addNewColumn(title);
        closeAddColumnModal();
    }

    document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && addColumnModal.classList.contains('active')) {
            closeAddColumnModal();
        }
    });

    renderBoard();
</script>
</body>
</html>